# ğŸ“ Part A â€” Theory (Short Questions)

Short, direct answers in my own words â€” no fluff.

---

## **1. Nine Pillars Understanding**

### **Q1: Why is using AI Development Agents for repetitive setup tasks better for your growth as a system architect?**

Because setup work doesnâ€™t grow your brain â€” design does.  
When agents handle boring steps (folders, configs, boilerplate), Iâ€™m free to focus on structure, flow, and decisions.  
Thatâ€™s how you grow as an architect, not by repeating the same setup 100 times.

---

### **Q2: How do the Nine Pillars help a developer grow into an M-Shaped Developer?**

Each pillar pushes me into a different domain â€” testing, specs, automation, refactoring, documentation, orchestration, agents.  
Working across all of these builds **depth in multiple areas**, not just one.  
Thatâ€™s exactly what makes someone â€œM-Shaped.â€

---

## **2. Vibe Coding vs Specification-Driven Development (SDD)**

### **Q3: Why does Vibe Coding usually create problems after one week?**

Because youâ€™re coding based on feelings, not structure.  
The first few days feel fast, but by the end of the week the codebase becomes messy, hard to extend, and confusing even for AI agents.  
No plan = chaos.

---

### **Q4: How does SDD prevent those problems?**

SDD makes you define the rules before you write the code.  
Clear specs = predictable results, fewer surprises, and a codebase that grows cleanly.  
It gives both you *and* the AI a solid roadmap.

---

## **3. Architecture Thinking**

### **Q5: How does architecture-first thinking change the developerâ€™s role in AIDD?**

I stop being â€œjust a coderâ€ and start being the person who shapes the whole system.  
AI writes most of the code â€” my job is to design how the system works and make decisions that keep everything consistent.

---

### **Q6: Why must developers think in layers and systems instead of raw code?**

Because modern apps arenâ€™t one big file â€” theyâ€™re layers that talk to each other.  
Thinking in layers helps me avoid spaghetti code, guide AI properly, and build systems that can grow without collapsing.

---

## âœ… End of Part A  
Straightforward answers. No overthinking.
